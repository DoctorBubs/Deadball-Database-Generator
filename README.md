# Deadball League Generator
#### Video Demo:  <https://youtu.be/-QXtK72PMT8> https://youtu.be/-QXtK72PMT8
#### Description:
This program is a tool used to create leagues and teams for the tabletop baseball simulator Deadball. When run,the program creates a sqlite3 database named "Deadball.db" if one does not exists, and then asks the user if they would like create a new league or add a new team to an existing league. If the user selects the latter option, and there are no leagues existing in the database already, then the user is prompted to create a new league. main.rs contains imports for libraries, as well as code for some of the steps in running the programs.

Each league has a name, and an indicator whether the players in the league are male or female only, or coed. The Deadball game also has rules for simulating modern era baseball, as well as the lower scoring style played in the ealry 1900s, so each league also has an indicator for the league era as well, which is defined under era.rs. All of these fields are chosen by the user, and there is a check to ensure that there are not multiple leagues in the same database with the same name. Afterwards, the league entry is added to the database. league.rs is where the league struct is defined, and contains most of the code for loading and unloading leagues.

Next, the user has the option to generate a new team . The user is prompted to insert a name for the new team, as well as an abbreviation of the name. For example, if a user was creating a team name after the Los Angeles Dodgers, the abbreviation might be "LAD". After a user inputs the name and abbreviation, there is a check in the database to ensure that there is not already a team in the same league with the same name or abbreviation, and if there is then the user is prompted to enter something else. However, it is OK to reuse team names if they are in different leagues. team.rs is where the Team struct is defined, and contains code to generate new teams and load teams from the database.

When generating a team, it contains several sets of player pools. Every teams has a starting lineup, bench, and starting rotation, and depending on the league era it might have a bullpen as well. We fill each pool with amount of randomly generated players, the code for which is mostly contained in players.rs. Each player contains a Rust option for the PD enum(which is defined in pd.rs), which is a simulation of RPG dice. Batters do note have a pitch die, so each batter pd is None, however they will be on average much better hitters. Pitchers pd fields will be Some(pd), however they will be on average worse hitters.

To generate a player, we generate a random name based off the league gender, however the rest of the batters fieldS are determined via PlayerQuality. PlayerQuality is a rust trait defined in player_quality.rs. We use it to create 2 sets of enums, BatterQuality and PitcherQuality, which via the trait are able to create players, with the higher quality variant of each enum able to create significantly better players for it's niche. PitcherQuality also accounts for the era of the league, with Ancient era pitchers having significantly higher skill ceiling then modern ones.

Each players also has a batter traits struct( defined in b_traits.rs), which is a collection of trait enums that lists how good a player is at defense, base-stealing, hitting for power, hitting for contact, and staying health. The trait enums are defined in traits.rs. Each player also has an option for a pitcher trait(defined in pitcher_traits.rs), with all batters having None, while pitchers have a chance to have Some(pitcher_trait).

After a team is generated for a league, the team and all its players are saved in the database. We also generate the team's team_score, which is a number based off player stats that is used in Deadball to simulate games without simulating every play. When a user is done adding teams to the league, a new folder is created under the name of the league if it does not exists already. For each team, a .txt files is created which contains a print out of every player pool in the team. We want each player pool to be sorted by quality, so we use lineup_scores.rs to sort pools containing hitters, and pitcher_rank_info to assist in ranking pitchers. The program then exits, and if a user later on adds new teams to the league the program is able to handle it.

There were a few design choices I debated. I originally planned to only have the program export plaintext in folders, and not contain a database at all, but instead used JSON to de-serialize leagues. However, after experimenting with adding sqlite in a git branch I found that it provided a nicer interface to have the user select existing leagues to add new teams. There are some leftover structs and fields in the program, such as the farmhand variant of the PitcherQuality enum, for features that I considered adding in, but decided not to due to time constrains. I decided to keep them in in case I decide to use this in the future. I considered adding a feature to allow users to edit players and teams directly in the program, however I determined that would add a level of complexity I did not want to pursue at this time. Users that would like to edit teams could edit the database themselves, or simply make copies of the plain text output to edit via a text editor. I may also go back later to make it possible to simulate most of a season via team score so a user can create a scenario for the last few games of a season, but I decided against adding it for now again due to complexity. I am proud of the current program, which is a quick way to Deadball leagues and teams for users to do with as they wish.


